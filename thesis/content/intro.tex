\section{Introduction}
\label{sec:introduction}

When evaluating a programming language for use on a project, we as programmers are faced with an ever-growing array of choices. These choices range from long-lived, well-established languages such as C or Fortran, to the very latest offerings such as Julia or Swift. Selecting a language is a process that is generally rooted in a combination of factors: suitability to the target platform, performance, expressiveness, and (often most importantly) the programmer's familiarity and comfort with the language.

This thesis will be a comparison of the relative strengths of the Rust programming language when compared to C and C++. To explore this, the problem of large-scale string matching will be examined with a focus on matching within DNA strings.

\subsection{String Matching}

The topic of string matching has long been a popular area of research in computer science. Before the paper by Knuth, Morris and Pratt in 1977~\cite{knuth.morris.pratt.1977} there was already considerable work being done. In the same year, Boyer and Moore published an improvement over the Knuth/Morris/Pratt algorithm with enhancements such as starting the match from the tail of the pattern rather than the head, and allowing for greater right-ward jumps through the string being searched~\cite{boyer.moore.1977}.

\subsection{Current Approaches}

\subsection{The Rust Language}

The Rust language began as a personal project of an employee of the Mozilla Corporation in 2006, with Mozilla beginning to sponsor the work in 2009 and officially announcing the project in 2010 (cite). The first pre-alpha numbered version of the compiler was Rust 0.1, which was released in January of 2012. The current (as of this writing) version of Rust is 1.63.0 and was released in August of 2022.

Syntactically, Rust most resembles C and C++. However, much of Rust's design is more influenced by functional programming principles~\cite[Chapter~13]{rpl.2019}. It organizes code into blocks using curly brackets and features typical control flow keywords such as \texttt{if}, \texttt{else}, \texttt{while}, and \texttt{for}. But it also treats almost every part of a function body as an expression, including the control flow operators~\cite[Chapter~6]{programming.rust.2021}. For example, the ternary operator of C is not provided but because an \texttt{if}-block is an expression one can get the same effect in code. Rust is a strongly typed and statically typed language, with generic functions to achieve type polymorphism.

An area where Rust is distinct from other C-based languages is in the way it manages memory and tracks values on the stack and heap. Rust uses an ownership system~\cite[Chapter~4]{programming.rust.2021} , with the ability to specify lifetime information for reference types. There is no automated garbage collection, and resources are managed through a convention of \textit{resource acquisition is initialization}~\cite{cpp.design.evolution.1994} with optional reference counting. Rust's design for memory safety does not permit null pointers, dangling pointers~\cite{taste.of.rust.2013}, or data races~\cite[Chapter~8.1]{rustonomicon}.
