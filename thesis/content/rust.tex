\section{An Introduction to Rust}
\label{sec:rust}

The Rust language began as a personal project of an employee of the Mozilla Corporation in 2006, with Mozilla beginning to sponsor the work in 2009 and officially announcing the project in 2010~\cite{asay.2021}. The first pre-alpha numbered version of the compiler was Rust 0.1, which was released in January of 2012. The current (as of this writing) version of Rust is 1.63.0 and was released in August of 2022.

This section will briefly highlight some basic elements of the Rust language so as to help in understanding later code samples.

\subsection{Rust Variables}

Rust variables are declared with the \texttt{let} keyword. By default, a Rust variable is declared as an immutable value. This can be changed by including the \texttt{mut} keyword in the declaration:

\begin{lstlisting}
// This value is immutable:
let value = 0;
// This value can be changed, however:
let mut value2 = 0;
\end{lstlisting}

A variable's declaration can include a type specification, but it is not required in cases where the type can be inferred from the right-hand side of the expression.

Rust supports pointers to data, using the \texttt{\&} character to indicate a pointer value rather than a direct value. Pointers may be immutable or mutable, and the data to which they point may be declared as mutable or immutable.

There are two compound types supported: the \textit{tuple} and the \textit{array}. These differ mainly in that a tuple's elements are not required to be all of the same type, whereas an array's elements must all be of the same type.

Lastly, Rust also provides support for structured types, enumerated types, and functions as first-class data types. Additionally, the standard library includes a range of common collection types, such as vectors, strings, and hash-maps.

\subsection{Rust Syntax}

Syntactically, Rust most resembles C and C++. However, much of Rust's design is more influenced by functional programming principles~\cite[Chapter~13]{rpl.2019}. It organizes code into blocks using curly brackets and features typical control flow keywords such as \texttt{if}, \texttt{else}, \texttt{while}, and \texttt{for}. But it also treats almost every part of a function body as an expression, including the control flow operators~\cite[Chapter~6]{programming.rust.2021}. For example, the ternary operator of C is not provided but because an \texttt{if}-block is an expression one can get the same effect in code:

\begin{lstlisting}[language=C]
// Ternary in C:
int offset = needs_offset ? 4 : 0;
\end{lstlisting}

\begin{lstlisting}
// Ternary in Rust:
let offset: u32 = if needs_offset { 4 } else { 0 };
\end{lstlisting}

The Rust version of the ternary is not limited to a single Boolean comparison. Just as C and C++ can nest ternary operators, the \texttt{if}-block equivalent in Rust can have multiple \texttt{else if} branches as well:

\begin{lstlisting}
// Select an HTTP listening port
let http_port: u32 = if user_port > 1023 {
    user_port
} else if is_secure {
    443
} else {
    80
};
\end{lstlisting}

Noteworthy in these sample listings is a particular syntactic feature of Rust: if the last expression of a block lacks a semicolon at the end, that value become the expression value of the block itself. So, in the above example all of \texttt{user\_port}, \texttt{443} and \texttt{80} are potential expression values of the \texttt{if}-block. The blocks they are in could have had many other statements prior to these lines, and the value of the expression would still be the line with no semicolon.

While it is true that a C or C++ program could also use a multi-armed \texttt{if}-\texttt{else} construct in place of a nested ternary, the expression in Rust allows \texttt{http_port} to be declared immutable from the outset. Were a C program to declare \texttt{http_port} as \texttt{const}, it could not then assign it within the arms of the \texttt{if}-\texttt{else} construct.

\subsection{Rust Typing}

Rust is a strongly typed and statically typed language, with generic functions to achieve type polymorphism.

\subsection{Rust and Memory Management}

An area where Rust is distinct from other C-based languages is in the way it manages memory and tracks values on the stack and heap. Rust uses an ownership system~\cite[Chapter~4]{programming.rust.2021} , with the ability to specify lifetime information for reference types. There is no automated garbage collection, and resources are managed through a convention of \textit{resource acquisition is initialization}~\cite{cpp.design.evolution.1994} with optional reference counting. Rust's design for memory safety does not permit null pointers, dangling pointers~\cite{taste.of.rust.2013}, or data races~\cite[Chapter~8.1]{rustonomicon}.
